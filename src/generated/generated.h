// Generated file - do not edit
// Created by meta.cpp

#ifndef GENERATED_H
#define GENERATED_H

// Shader sources
const char* renderer_metal_rect_shader_src = 
    "#include <metal_stdlib>\n"
    "#include <simd/simd.h>\n"
    "using namespace metal;\n"
    "\n"
    "struct VertexInput {\n"
    "    float4 dst_rect [[attribute(0)]];\n"
    "    float4 src_rect [[attribute(1)]];\n"
    "    float4 colors_0 [[attribute(2)]];\n"
    "    float4 colors_1 [[attribute(3)]];\n"
    "    float4 colors_2 [[attribute(4)]];\n"
    "    float4 colors_3 [[attribute(5)]];\n"
    "    float4 corner_radii [[attribute(6)]];\n"
    "    float4 style [[attribute(7)]]; // border_thickness, edge_softness, white_texture_override, unused\n"
    "};\n"
    "\n"
    "struct VertexOutput {\n"
    "    float4 position [[position]];\n"
    "    float2 sdf_sample_pos;\n"
    "    float2 texcoord_pct;\n"
    "    float2 rect_half_size_px;\n"
    "    float4 tint;\n"
    "    float corner_radius;\n"
    "    float border_thickness;\n"
    "    float softness;\n"
    "    float omit_texture;\n"
    "};\n"
    "\n"
    "struct Uniforms {\n"
    "    float2 viewport_size_px;\n"
    "    float opacity;\n"
    "    float4x4 texture_sample_channel_map;\n"
    "};\n"
    "\n"
    "vertex VertexOutput rect_vertex_main(\n"
    "    uint vertex_id [[vertex_id]],\n"
    "    uint instance_id [[instance_id]],\n"
    "    const device VertexInput* instances [[buffer(0)]],\n"
    "    constant Uniforms& uniforms [[buffer(1)]]\n"
    ")\n"
    "{\n"
    "    const float2 vertices[4] = {\n"
    "        float2(-1.0, -1.0),\n"
    "        float2(-1.0, 1.0),\n"
    "        float2(1.0, -1.0),\n"
    "        float2(1.0, 1.0)\n"
    "    };\n"
    "    \n"
    "    const device VertexInput& instance = instances[instance_id];\n"
    "    \n"
    "    float2 dst_half_size = (instance.dst_rect.zw - instance.dst_rect.xy) / 2.0;\n"
    "    float2 dst_center = (instance.dst_rect.zw + instance.dst_rect.xy) / 2.0;\n"
    "    float2 dst_position = vertices[vertex_id] * dst_half_size + dst_center;\n"
    "    \n"
    "    float2 src_half_size = (instance.src_rect.zw - instance.src_rect.xy) / 2.0;\n"
    "    float2 src_center = (instance.src_rect.zw + instance.src_rect.xy) / 2.0;\n"
    "    float2 src_position = vertices[vertex_id] * src_half_size + src_center;\n"
    "    \n"
    "    const float4 colors[4] = {\n"
    "        instance.colors_0,\n"
    "        instance.colors_1,\n"
    "        instance.colors_2,\n"
    "        instance.colors_3\n"
    "    };\n"
    "    float4 color = colors[vertex_id];\n"
    "    \n"
    "    const float corner_radii[4] = {\n"
    "        instance.corner_radii.x,\n"
    "        instance.corner_radii.y,\n"
    "        instance.corner_radii.z,\n"
    "        instance.corner_radii.w\n"
    "    };\n"
    "    float corner_radius = corner_radii[vertex_id];\n"
    "    \n"
    "    float2 dst_verts_pct = float2(\n"
    "        ((vertex_id >> 1u) != 1u) ? 1.0 : 0.0,\n"
    "        ((vertex_id & 1u) != 0u) ? 0.0 : 1.0\n"
    "    );\n"
    "    \n"
    "    VertexOutput output;\n"
    "    output.position = float4(2.0 * dst_position / uniforms.viewport_size_px - 1.0, 0.0, 1.0);\n"
    "    output.position.y = -output.position.y;\n"
    "    output.sdf_sample_pos = dst_position - dst_center;\n"
    "    output.texcoord_pct = src_position;\n"
    "    output.rect_half_size_px = dst_half_size;\n"
    "    output.tint = color;\n"
    "    output.corner_radius = corner_radius;\n"
    "    output.border_thickness = instance.style.x;\n"
    "    output.softness = instance.style.y;\n"
    "    output.omit_texture = instance.style.z;\n"
    "    \n"
    "    return output;\n"
    "}\n"
    "\n"
    "float rounded_rect_sdf(float2 sample_pos, float2 rect_half_size, float corner_radius)\n"
    "{\n"
    "    corner_radius = min(corner_radius, min(rect_half_size.x, rect_half_size.y));\n"
    "    float2 interior_half_size = rect_half_size - corner_radius;\n"
    "    float2 d = abs(sample_pos) - interior_half_size;\n"
    "    float dist = length(max(d, 0.0)) - corner_radius;\n"
    "    return dist;\n"
    "}\n"
    "\n"
    "fragment float4 rect_fragment_main(\n"
    "    VertexOutput input [[stage_in]],\n"
    "    texture2d<float> tex_color [[texture(0)]],\n"
    "    sampler tex_sampler [[sampler(0)]],\n"
    "    constant Uniforms& uniforms [[buffer(1)]]\n"
    ")\n"
    "{\n"
    "    float dist = rounded_rect_sdf(input.sdf_sample_pos, input.rect_half_size_px, input.corner_radius);\n"
    "    float shape_coverage = 1.0 - smoothstep(-input.softness, input.softness, dist);\n"
    "    \n"
    "    float4 tex_sample = float4(1.0);\n"
    "    if (input.omit_texture < 0.5)\n"
    "    {\n"
    "        tex_sample = tex_color.sample(tex_sampler, input.texcoord_pct);\n"
    "        tex_sample = uniforms.texture_sample_channel_map * tex_sample;\n"
    "    }\n"
    "    \n"
    "    float4 final_color = input.tint * tex_sample;\n"
    "    \n"
    "    if (input.border_thickness > 0.0)\n"
    "    {\n"
    "        float inner_dist = dist + input.border_thickness;\n"
    "        float inner_coverage = 1.0 - smoothstep(-input.softness, input.softness, inner_dist);\n"
    "        shape_coverage = shape_coverage - inner_coverage;\n"
    "    }\n"
    "    \n"
    "    final_color.a *= shape_coverage * uniforms.opacity;\n"
    "    return final_color;\n"
    "}\n";

const char* renderer_metal_blur_shader_src = 
    "#include <metal_stdlib>\n"
    "#include <simd/simd.h>\n"
    "using namespace metal;\n"
    "\n"
    "struct BlurUniforms {\n"
    "    float2 viewport_size;\n"
    "    float2 rect_min;\n"
    "    float2 rect_max;\n"
    "    float2 clip_min;\n"
    "    float2 clip_max;\n"
    "    float blur_size;\n"
    "    float4 corner_radii;\n"
    "};\n"
    "\n"
    "struct VertexOutput {\n"
    "    float4 position [[position]];\n"
    "    float2 texcoord;\n"
    "};\n"
    "\n"
    "vertex VertexOutput blur_vertex_main(\n"
    "    uint vertex_id [[vertex_id]],\n"
    "    constant BlurUniforms& uniforms [[buffer(0)]]\n"
    ")\n"
    "{\n"
    "    const float2 vertices[4] = {\n"
    "        float2(0.0, 0.0),\n"
    "        float2(0.0, 1.0),\n"
    "        float2(1.0, 0.0),\n"
    "        float2(1.0, 1.0)\n"
    "    };\n"
    "    \n"
    "    float2 vert = vertices[vertex_id];\n"
    "    float2 pos = mix(uniforms.rect_min, uniforms.rect_max, vert);\n"
    "    \n"
    "    VertexOutput output;\n"
    "    output.position = float4(2.0 * pos / uniforms.viewport_size - 1.0, 0.0, 1.0);\n"
    "    output.position.y = -output.position.y;\n"
    "    output.texcoord = pos / uniforms.viewport_size;\n"
    "    \n"
    "    return output;\n"
    "}\n"
    "\n"
    "fragment float4 blur_fragment_main(\n"
    "    VertexOutput input [[stage_in]],\n"
    "    texture2d<float> input_tex [[texture(0)]],\n"
    "    sampler tex_sampler [[sampler(0)]],\n"
    "    constant BlurUniforms& uniforms [[buffer(0)]]\n"
    ")\n"
    "{\n"
    "    float2 tex_size = float2(input_tex.get_width(), input_tex.get_height());\n"
    "    float2 texel_size = 1.0 / tex_size;\n"
    "    \n"
    "    float4 color = float4(0.0);\n"
    "    float total_weight = 0.0;\n"
    "    \n"
    "    int sample_count = int(uniforms.blur_size);\n"
    "    for (int y = -sample_count; y <= sample_count; y++)\n"
    "    {\n"
    "        for (int x = -sample_count; x <= sample_count; x++)\n"
    "        {\n"
    "            float2 offset = float2(x, y) * texel_size;\n"
    "            float weight = exp(-float(x*x + y*y) / (2.0 * uniforms.blur_size * uniforms.blur_size));\n"
    "            \n"
    "            color += input_tex.sample(tex_sampler, input.texcoord + offset) * weight;\n"
    "            total_weight += weight;\n"
    "        }\n"
    "    }\n"
    "    \n"
    "    return color / total_weight;\n"
    "}\n";

const char* renderer_metal_mesh_shader_src = 
    "#include <metal_stdlib>\n"
    "#include <simd/simd.h>\n"
    "using namespace metal;\n"
    "\n"
    "struct VertexInput {\n"
    "    float3 position [[attribute(0)]];\n"
    "    float2 texcoord [[attribute(1)]];\n"
    "    float3 normal [[attribute(2)]];\n"
    "    float4 color [[attribute(3)]];\n"
    "};\n"
    "\n"
    "struct MeshInstance {\n"
    "    float4x4 transform;\n"
    "};\n"
    "\n"
    "struct MeshUniforms {\n"
    "    float4x4 view;\n"
    "    float4x4 projection;\n"
    "    float2 viewport_size;\n"
    "    float2 clip_min;\n"
    "    float2 clip_max;\n"
    "};\n"
    "\n"
    "struct VertexOutput {\n"
    "    float4 position [[position]];\n"
    "    float2 texcoord;\n"
    "    float3 normal;\n"
    "    float4 color;\n"
    "    float3 world_pos;\n"
    "};\n"
    "\n"
    "vertex VertexOutput mesh_vertex_main(\n"
    "    VertexInput in [[stage_in]],\n"
    "    uint instance_id [[instance_id]],\n"
    "    const device MeshInstance* instances [[buffer(1)]],\n"
    "    constant MeshUniforms& uniforms [[buffer(2)]]\n"
    ")\n"
    "{\n"
    "    MeshInstance instance = instances[instance_id];\n"
    "    \n"
    "    float4 world_pos = instance.transform * float4(in.position, 1.0);\n"
    "    float4 view_pos = uniforms.view * world_pos;\n"
    "    float4 clip_pos = uniforms.projection * view_pos;\n"
    "    \n"
    "    float3x3 normal_matrix = float3x3(instance.transform[0].xyz,\n"
    "                                       instance.transform[1].xyz,\n"
    "                                       instance.transform[2].xyz);\n"
    "    \n"
    "    VertexOutput output;\n"
    "    output.position = clip_pos;\n"
    "    output.texcoord = in.texcoord;\n"
    "    output.normal = normalize(normal_matrix * in.normal);\n"
    "    output.color = in.color;\n"
    "    output.world_pos = world_pos.xyz;\n"
    "    \n"
    "    return output;\n"
    "}\n"
    "\n"
    "fragment float4 mesh_fragment_main(\n"
    "    VertexOutput input [[stage_in]],\n"
    "    texture2d<float> albedo_tex [[texture(0)]],\n"
    "    sampler tex_sampler [[sampler(0)]]\n"
    ")\n"
    "{\n"
    "    float4 albedo = albedo_tex.sample(tex_sampler, input.texcoord);\n"
    "    float4 color = albedo * input.color;\n"
    "    \n"
    "    // Simple directional lighting\n"
    "    float3 light_dir = normalize(float3(1.0, 1.0, 1.0));\n"
    "    float ndotl = max(dot(input.normal, light_dir), 0.0);\n"
    "    float3 diffuse = color.rgb * (0.3 + 0.7 * ndotl);\n"
    "    \n"
    "    return float4(diffuse, color.a);\n"
    "}\n";

#endif // GENERATED_H
